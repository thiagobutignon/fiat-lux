/**
 * Feature Slice Protocol Compiler
 *
 * Compiles Feature Slice (.gl) to executable code
 *
 * Pipeline:
 * 1. Parse S-expressions â†’ Feature Slice AST
 * 2. Validate (Clean Architecture + Constitutional + Grammar)
 * 3. Generate outputs (Backend + Frontend + Infrastructure)
 */

import { parseFeatureSlice, parseExtendedDefinition } from './feature-slice-parser';
import { FeatureSliceValidator } from './feature-slice-validator';
import { FeatureSliceDef } from '../core/feature-slice-ast';
import { transpileProgram } from './transpiler';

// ============================================================================
// Compiler Options
// ============================================================================

export interface FeatureSliceCompileOptions {
  target?: 'javascript' | 'typescript' | 'llvm';
  validate?: boolean;
  generateDocker?: boolean;
  generateK8s?: boolean;
  optimize?: boolean;
}

export interface FeatureSliceCompileResult {
  backend: string;
  frontend?: string;
  docker?: string;
  kubernetes?: string;
  errors: string[];
  warnings: string[];
}

// ============================================================================
// Feature Slice Compiler
// ============================================================================

export class FeatureSliceCompiler {
  private validator = new FeatureSliceValidator();

  /**
   * Compile Feature Slice to executable code
   *
   * @param source - S-expressions (parsed .gl file)
   * @param options - Compilation options
   */
  compile(source: any[], options: FeatureSliceCompileOptions = {}): FeatureSliceCompileResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    try {
      // Step 1: Parse Feature Slice
      const featureSlice = parseFeatureSlice(source);

      // Step 2: Validate (optional, but recommended)
      if (options.validate !== false) {
        try {
          this.validator.validate(featureSlice);
          warnings.push(...this.validator.validateWithWarnings(featureSlice));
        } catch (e: any) {
          errors.push(`Validation failed: ${e.message}`);
          return { backend: '', errors, warnings };
        }
      }

      // Step 3: Generate code
      const backend = this.generateBackend(featureSlice);
      const frontend = this.generateFrontend(featureSlice);
      const docker = options.generateDocker ? this.generateDocker(featureSlice) : undefined;
      const kubernetes = options.generateK8s ? this.generateKubernetes(featureSlice) : undefined;

      return {
        backend,
        frontend,
        docker,
        kubernetes,
        errors,
        warnings
      };

    } catch (e: any) {
      errors.push(`Compilation failed: ${e.message}`);
      return { backend: '', errors, warnings };
    }
  }

  /**
   * Generate backend code (Node.js/TypeScript)
   */
  private generateBackend(featureSlice: FeatureSliceDef): string {
    const parts: string[] = [];

    // Generate imports
    parts.push('// Feature Slice: ' + featureSlice.name);
    parts.push('// Generated by Feature Slice Compiler\n');

    // Generate agent config
    if (featureSlice.agent) {
      parts.push(this.generateAgentConfig(featureSlice));
    }

    // Generate layers (in order: domain â†’ data â†’ infrastructure)
    const orderedLayers = ['domain', 'data', 'infrastructure', 'validation', 'presentation'];
    for (const layerType of orderedLayers) {
      const layer = featureSlice.layers.find(l => l.layerType === layerType);
      if (layer) {
        parts.push(`\n// ============================================`);
        parts.push(`// LAYER: ${layerType.toUpperCase()}`);
        parts.push(`// ============================================\n`);

        // Transpile layer definitions
        const code = transpileProgram(layer.definitions);
        parts.push(code);
      }
    }

    // Generate storage configuration
    if (featureSlice.storage) {
      parts.push(this.generateStorage(featureSlice));
    }

    // Generate network/API routes
    if (featureSlice.network) {
      parts.push(this.generateNetwork(featureSlice));
    }

    // Generate observability
    if (featureSlice.observability) {
      parts.push(this.generateObservability(featureSlice));
    }

    // Generate main entry point
    if (featureSlice.main) {
      parts.push(this.generateMain(featureSlice));
    }

    return parts.join('\n');
  }

  /**
   * Generate agent configuration
   */
  private generateAgentConfig(featureSlice: FeatureSliceDef): string {
    const agent = featureSlice.agent!;

    return `
// Agent Configuration
const AGENT_CONFIG = {
  name: "${agent.name}",
  domain: "${agent.domain}",
  expertise: ${JSON.stringify(agent.expertise)},
  constitutional: ${JSON.stringify(agent.constitutional)},
  knowledge: "${agent.knowledge}",
  constraints: ${JSON.stringify(agent.constraints)},
  prompt: {
    role: "${agent.prompt.role}",
    tone: "${agent.prompt.tone}",
    knowledgeSources: "${agent.prompt.knowledgeSources}",
    constitutionalPrinciples: "${agent.prompt.constitutionalPrinciples}",
    attentionTracking: ${agent.prompt.attentionTracking}
  }
};
`;
  }

  /**
   * Generate storage configuration
   */
  private generateStorage(featureSlice: FeatureSliceDef): string {
    const storage = featureSlice.storage!;
    const parts: string[] = [];

    parts.push('\n// Storage Configuration');

    if (storage.relational) {
      parts.push(`
const db = {
  type: '${storage.relational.type}',
  url: process.env.DATABASE_URL || '${storage.relational.url}',
  pool: ${storage.relational.connectionPool || 10}
};
`);
    }

    if (storage.cache) {
      parts.push(`
const cache = {
  type: '${storage.cache.type}',
  url: process.env.REDIS_URL || '${storage.cache.url}',
  ttl: ${storage.cache.ttlDefault || 3600}
};
`);
    }

    return parts.join('\n');
  }

  /**
   * Generate network/API routes
   */
  private generateNetwork(featureSlice: FeatureSliceDef): string {
    const network = featureSlice.network!;
    const parts: string[] = [];

    parts.push('\n// Network Configuration');
    parts.push(`
const app = require('express')();
const PORT = ${network.apiConfig.port};

${network.apiConfig.cors ? "app.use(require('cors')());" : ''}
app.use(require('body-parser').json());
`);

    // Generate routes
    for (const route of network.routes) {
      const method = route.method.toLowerCase();
      const authMiddleware = route.auth ? ', authMiddleware' : '';
      const rateLimitMiddleware = route.rateLimit ? ', rateLimitMiddleware' : '';

      parts.push(`
app.${method}('${route.path}'${authMiddleware}${rateLimitMiddleware}, async (req, res) => {
  try {
    ${route.constitutional ? '// Constitutional check\n    await validateConstitutional(req);' : ''}

    const result = await ${route.handler}(req.body || req.query);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
`);
    }

    // Generate server start
    parts.push(`
// Start server
app.listen(PORT, () => {
  console.log(\`ðŸš€ \${AGENT_CONFIG.name} listening on port \${PORT}\`);
});
`);

    return parts.join('\n');
  }

  /**
   * Generate observability (metrics + traces)
   */
  private generateObservability(featureSlice: FeatureSliceDef): string {
    const obs = featureSlice.observability!;
    const parts: string[] = [];

    parts.push('\n// Observability');

    // Generate metrics
    parts.push('\nconst metrics = {');
    for (const metric of obs.metrics) {
      const labels = metric.labels ? `, labels: ${JSON.stringify(metric.labels)}` : '';
      const buckets = metric.buckets ? `, buckets: ${JSON.stringify(metric.buckets)}` : '';

      parts.push(`  ${metric.name}: new ${metric.type.charAt(0).toUpperCase() + metric.type.slice(1)}({
    name: '${metric.name}',
    help: '${metric.description}'${labels}${buckets}
  }),`);
    }
    parts.push('};');

    // Generate traces
    if (obs.traces.length > 0) {
      parts.push('\nconst traces = {');
      for (const trace of obs.traces) {
        parts.push(`  ${trace.name}: {
    enabled: ${trace.enabled},
    export: '${trace.export}'${trace.description ? `,\n    description: '${trace.description}'` : ''}
  },`);
      }
      parts.push('};');
    }

    return parts.join('\n');
  }

  /**
   * Generate main entry point
   */
  private generateMain(featureSlice: FeatureSliceDef): string {
    const main = featureSlice.main!;

    return `
// Main Entry Point
async function main() {
  console.log('ðŸš€ Starting ${featureSlice.name}...');

  // Initialize components
  await ${main.startFunction}();

  console.log('âœ… ${featureSlice.name} ready!');
}

// Start application
if (require.main === module) {
  main().catch(error => {
    console.error('âŒ Failed to start:', error);
    process.exit(1);
  });
}

module.exports = { main, AGENT_CONFIG };
`;
  }

  /**
   * Generate frontend code (React/Vue/etc.)
   */
  private generateFrontend(featureSlice: FeatureSliceDef): string | undefined {
    if (!featureSlice.ui) return undefined;

    // TODO: Implement UI generation
    return '// Frontend generation not implemented yet';
  }

  /**
   * Generate Dockerfile
   */
  private generateDocker(featureSlice: FeatureSliceDef): string {
    return `
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --production

COPY . .

EXPOSE ${featureSlice.network?.apiConfig.port || 8080}

CMD ["node", "dist/${featureSlice.name}.js"]
`;
  }

  /**
   * Generate Kubernetes manifests
   */
  private generateKubernetes(featureSlice: FeatureSliceDef): string {
    const port = featureSlice.network?.apiConfig.port || 8080;

    return `
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${featureSlice.name}
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ${featureSlice.name}
  template:
    metadata:
      labels:
        app: ${featureSlice.name}
    spec:
      containers:
      - name: ${featureSlice.name}
        image: ${featureSlice.name}:latest
        ports:
        - containerPort: ${port}
        env:
        - name: NODE_ENV
          value: production
---
apiVersion: v1
kind: Service
metadata:
  name: ${featureSlice.name}
spec:
  selector:
    app: ${featureSlice.name}
  ports:
  - port: 80
    targetPort: ${port}
  type: LoadBalancer
`;
  }
}

// ============================================================================
// Convenience Functions
// ============================================================================

/**
 * Compile Feature Slice from S-expressions
 */
export function compileFeatureSlice(
  source: any[],
  options: FeatureSliceCompileOptions = {}
): FeatureSliceCompileResult {
  const compiler = new FeatureSliceCompiler();
  return compiler.compile(source, options);
}

/**
 * Compile and write to files
 */
export function compileAndWrite(
  source: any[],
  outputDir: string,
  options: FeatureSliceCompileOptions = {}
): void {
  const fs = require('fs');
  const path = require('path');

  const result = compileFeatureSlice(source, options);

  if (result.errors.length > 0) {
    console.error('âŒ Compilation errors:');
    result.errors.forEach(e => console.error('  -', e));
    process.exit(1);
  }

  // Create output directory
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write backend
  fs.writeFileSync(
    path.join(outputDir, 'index.js'),
    result.backend
  );

  // Write frontend (if exists)
  if (result.frontend) {
    fs.writeFileSync(
      path.join(outputDir, 'frontend.js'),
      result.frontend
    );
  }

  // Write Docker (if requested)
  if (result.docker) {
    fs.writeFileSync(
      path.join(outputDir, 'Dockerfile'),
      result.docker
    );
  }

  // Write Kubernetes (if requested)
  if (result.kubernetes) {
    fs.writeFileSync(
      path.join(outputDir, 'k8s.yaml'),
      result.kubernetes
    );
  }

  // Print warnings
  if (result.warnings.length > 0) {
    console.warn('âš ï¸  Warnings:');
    result.warnings.forEach(w => console.warn('  -', w));
  }

  console.log('âœ… Compilation successful!');
  console.log(`   Output: ${outputDir}/`);
}
