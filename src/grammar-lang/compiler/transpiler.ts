/**
 * Grammar Language Transpiler
 *
 * Transpiles Grammar Language AST to JavaScript
 * Phase 1: Run on existing V8 runtime
 */

import { Expr, Definition, FunctionDef } from '../core/ast';
import { Type } from '../core/types';

// ============================================================================
// Expression Transpiler
// ============================================================================

export function transpileExpr(expr: Expr): string {
  switch (expr.kind) {
    case 'literal':
      if (typeof expr.value === 'string') {
        return JSON.stringify(expr.value);
      }
      if (expr.value === null) {
        return 'null';
      }
      return String(expr.value);

    case 'var':
      return expr.name;

    case 'let':
      // const name = value
      const value = transpileExpr(expr.value);
      if (expr.body) {
        // IIFE for scoping
        const body = transpileExpr(expr.body);
        return `(() => { const ${expr.name} = ${value}; return ${body}; })()`;
      }
      return `const ${expr.name} = ${value}`;

    case 'if': {
      const cond = transpileExpr(expr.condition);
      const thenBranch = transpileExpr(expr.then);
      const elseBranch = transpileExpr(expr.else);
      return `(${cond} ? ${thenBranch} : ${elseBranch})`;
    }

    case 'call': {
      const fn = transpileExpr(expr.fn);
      const args = expr.args.map(transpileExpr).join(', ');
      return `${fn}(${args})`;
    }

    case 'lambda': {
      const params = expr.params.map(([name]) => name).join(', ');
      const body = transpileExpr(expr.body);
      return `((${params}) => ${body})`;
    }

    case 'list': {
      const elements = expr.elements.map(transpileExpr).join(', ');
      return `[${elements}]`;
    }

    case 'record': {
      const fields = Array.from(expr.fields.entries())
        .map(([name, expr]) => `${name}: ${transpileExpr(expr)}`)
        .join(', ');
      return `{ ${fields} }`;
    }
  }
}

// ============================================================================
// Definition Transpiler
// ============================================================================

export function transpileDefinition(def: Definition): string {
  switch (def.kind) {
    case 'function': {
      const params = def.params.map(([name]) => name).join(', ');
      const body = transpileExpr(def.body);
      return `function ${def.name}(${params}) {\n  return ${body};\n}`;
    }

    case 'typedef':
      // TypeScript type alias (commented in JS output)
      return `// type ${def.name} = ${JSON.stringify(def.type)}`;

    case 'module': {
      const defs = def.definitions.map(transpileDefinition).join('\n\n');
      return `// module ${def.name}\n${defs}`;
    }
  }
}

// ============================================================================
// Program Transpiler
// ============================================================================

export function transpileProgram(definitions: Definition[]): string {
  const header = `/**
 * Transpiled from Grammar Language
 * Generated by Grammar Language Compiler
 */

`;

  const body = definitions.map(transpileDefinition).join('\n\n');

  return header + body;
}
