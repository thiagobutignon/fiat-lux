/**
 * Auto-Commit System - O(1) Version Control
 *
 * Detects changes (human OR AGI) and auto-commits without manual intervention.
 * Uses content-addressable storage for O(1) diff calculation.
 *
 * Philosophy:
 * - Glass box (100% transparent)
 * - O(1) complexity (hash-based)
 * - No manual git commands
 * - Works for human AND AGI changes
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';
import * as crypto from 'crypto';
import { vcsConstitutionalValidator } from './constitutional-integration';
import {
  createCommitRequest,
  generateSecurityMetadata,
} from '../security/git-operation-guard';
import {
  CognitiveBehaviorGuard,
  shouldProceedWithOperation,
  getCognitiveBehaviorSummary,
  formatCognitiveBehaviorAnalysis,
} from '../security/cognitive-behavior-guard';
import { SecurityStorage } from '../security/security-storage';
import { UserSecurityProfiles } from '../security/types';

// ===== TYPES =====

interface FileState {
  path: string;
  hash: string;           // SHA256 content hash
  lastModified: number;   // Timestamp
  author: 'human' | 'agi';
  version: string;        // Semver
}

interface DiffResult {
  linesAdded: number;
  linesRemoved: number;
  diff: string;
}

// ===== STATE (Content-Addressable) =====

// O(1) lookup by file path â†’ state
const fileStates = new Map<string, FileState>();

// O(1) lookup by hash â†’ file path
const hashIndex = new Map<string, string>();

// ===== CORE FUNCTIONS =====

/**
 * Calculate SHA256 hash of file content
 * O(1) per file (constant size .gl/.glass files)
 */
function calculateHash(filePath: string): string {
  const content = fs.readFileSync(filePath, 'utf-8');
  return crypto.createHash('sha256').update(content).digest('hex');
}

/**
 * Detect author based on change patterns
 * AGI: immediate changes (< 1s) from GLM/GSX/GLC
 * Human: typing delay, manual edits
 */
function detectAuthor(filePath: string): 'human' | 'agi' {
  const stats = fs.statSync(filePath);
  const now = Date.now();
  const timeSinceModified = now - stats.mtimeMs;

  // Check if process is AGI tool (GLM/GSX/GLC)
  try {
    const parentProcess = process.env.PARENT_PROCESS || '';
    if (parentProcess.includes('glm') ||
        parentProcess.includes('gsx') ||
        parentProcess.includes('glc')) {
      return 'agi';
    }
  } catch {
    // Fallback to timing heuristic
  }

  // AGI changes are typically immediate (< 1s)
  // Human changes have typing delay (> 1s)
  return timeSinceModified < 1000 ? 'agi' : 'human';
}

/**
 * Calculate diff between current and previous version
 * O(1) - uses git's internal index (content-addressable)
 */
function calculateDiff(filePath: string): DiffResult {
  let diff = '';

  try {
    // Try unstaged diff first
    diff = execSync(`git diff -- "${filePath}"`, {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
  } catch {
    try {
      // Fall back to staged diff
      diff = execSync(`git diff --cached -- "${filePath}"`, {
        encoding: 'utf-8',
        stdio: ['pipe', 'pipe', 'pipe']
      });
    } catch {
      // File not in git yet
      diff = '';
    }
  }

  const linesAdded = (diff.match(/^\+(?!\+)/gm) || []).length;
  const linesRemoved = (diff.match(/^\-(?!\-)/gm) || []).length;

  return { linesAdded, linesRemoved, diff };
}

/**
 * Generate semantic commit message
 * LLM-style message generation
 */
function generateCommitMessage(
  filePath: string,
  author: 'human' | 'agi',
  diffResult: DiffResult
): string {
  const fileName = path.basename(filePath);
  const { linesAdded, linesRemoved } = diffResult;

  // Semantic prefix based on change type
  let prefix = 'feat';
  if (linesAdded === 0 && linesRemoved > 0) {
    prefix = 'refactor';
  } else if (linesAdded > 0 && linesRemoved > 0) {
    prefix = 'fix';
  }

  return `${prefix}: auto-commit ${fileName}

Author: ${author}
Changes: +${linesAdded}/-${linesRemoved}

ðŸ§¬ Auto-generated by VCS (O(1))

Co-Authored-By: ${author === 'agi' ? 'AGI <agi@fiat.ai>' : 'Human <human@fiat.ai>'}`;
}

/**
 * Auto-commit file changes
 * O(1) - no scanning, hash-based detection
 *
 * Constitutional Enforcement: Validates against Layer 1 Constitutional AI
 * before executing commit. Blocks commits that violate universal principles.
 *
 * Dual-Layer Security (VERMELHO + CINZA):
 * - VERMELHO: Validates behavioral biometrics (duress/coercion detection)
 * - CINZA: Validates cognitive integrity (manipulation detection in commit message)
 * Creates auto-snapshots when suspicious behavior or manipulation detected.
 */
export async function autoCommit(
  filePath: string,
  userProfiles?: UserSecurityProfiles,
  userId?: string,
  storage?: SecurityStorage
): Promise<boolean> {
  // Calculate current hash (O(1))
  const currentHash = calculateHash(filePath);
  const previousState = fileStates.get(filePath);

  // Check if file changed (O(1) hash comparison)
  if (previousState && previousState.hash === currentHash) {
    return false; // No changes detected
  }

  // Detect author (O(1))
  const author = detectAuthor(filePath);

  // Calculate diff (O(1) - git uses content-addressable storage)
  const diffResult = calculateDiff(filePath);

  // Skip if no actual changes
  if (diffResult.linesAdded === 0 && diffResult.linesRemoved === 0) {
    return false;
  }

  // Generate commit message
  const message = generateCommitMessage(filePath, author, diffResult);

  // ===== CONSTITUTIONAL VALIDATION (BEFORE COMMIT) =====
  // Integration with Layer 1 Constitutional AI System
  // Uses existing ConstitutionEnforcer - does NOT reimplement
  try {
    const constitutionalResult = await vcsConstitutionalValidator.validateCommit(
      filePath,
      diffResult.diff,
      author
    );

    // Block commit if constitutional violation detected
    if (!constitutionalResult.allowed) {
      console.error('âŒ CONSTITUTIONAL VIOLATION - Commit BLOCKED');
      console.error(vcsConstitutionalValidator.formatVCSReport(constitutionalResult));
      console.error(`   File: ${filePath}`);
      console.error(`   Author: ${author}`);
      if (constitutionalResult.blockedReason) {
        console.error(`   Reason: ${constitutionalResult.blockedReason}`);
      }
      if (constitutionalResult.suggestedAction) {
        console.error(`   Suggested: ${constitutionalResult.suggestedAction}`);
      }
      return false; // Commit rejected by constitutional enforcement
    }

    console.log('âœ… Constitutional validation passed');
  } catch (constitutionalError) {
    console.error(`âš ï¸  Constitutional validation error: ${constitutionalError}`);
    console.error('   Proceeding with commit (fail-open for availability)');
    // Fail-open: if constitutional system is down, allow commit but log warning
  }

  // ===== DUAL-LAYER SECURITY VALIDATION (VERMELHO + CINZA + VERDE) =====
  // Integration with dual-layer security system
  // - VERMELHO: Behavioral biometrics (duress/coercion)
  // - CINZA: Cognitive manipulation detection
  // Validates user's behavioral + cognitive state before Git commit
  let securityMetadata = '';

  if (userProfiles && userId && storage) {
    try {
      const cognitiveBehaviorGuard = new CognitiveBehaviorGuard(storage);

      // Create commit request
      const commitRequest = createCommitRequest(
        userId,
        filePath,
        message,
        author,
        { lines_added: diffResult.linesAdded, lines_removed: diffResult.linesRemoved }
      );

      // Validate dual-layer security (behavioral + cognitive)
      const securityResult = await cognitiveBehaviorGuard.validateGitOperation(
        commitRequest,
        userProfiles
      );

      console.log('ðŸ”’ Dual-layer security validation:');
      console.log(getCognitiveBehaviorSummary(securityResult));

      // Block commit if security validation failed
      if (!shouldProceedWithOperation(securityResult)) {
        console.error('âŒ SECURITY VIOLATION - Commit BLOCKED');
        console.error(`   Decision: ${securityResult.decision.toUpperCase()}`);
        console.error(`   Reason: ${securityResult.reason}`);
        console.error(`   File: ${filePath}`);
        console.error(`   Author: ${author}`);

        // Show detailed cognitive-behavior analysis
        if (securityResult.cognitive_analysis) {
          console.error('\n' + formatCognitiveBehaviorAnalysis(securityResult.cognitive_analysis));
        }

        if (securityResult.snapshot_created) {
          console.error(`   ðŸ“¸ Duress snapshot saved: ${securityResult.snapshot_path}`);
        }

        if (securityResult.manipulation_snapshot_created) {
          console.error(`   ðŸ§  Manipulation snapshot saved: ${securityResult.manipulation_snapshot_path}`);
        }

        return false; // Commit rejected by dual-layer security
      }

      // Generate security metadata for commit message
      securityMetadata = generateSecurityMetadata(securityResult.security_context);

      // Add cognitive analysis metadata if available
      if (securityResult.cognitive_analysis) {
        const cogAnalysis = securityResult.cognitive_analysis;
        securityMetadata += `\nX-Cognitive-Manipulation: ${cogAnalysis.cognitive.manipulation_detected}`;
        securityMetadata += `\nX-Manipulation-Techniques: ${cogAnalysis.cognitive.techniques_found.length}`;
        securityMetadata += `\nX-Threat-Level: ${cogAnalysis.combined.threat_level}`;
        securityMetadata += `\nX-Risk-Score: ${(cogAnalysis.combined.risk_score * 100).toFixed(1)}%`;
      }

      console.log('âœ… Dual-layer security validation passed');
    } catch (securityError) {
      console.error(`âš ï¸  Dual-layer security validation error: ${securityError}`);
      console.error('   Proceeding with commit (fail-open for availability)');
      // Fail-open: if security system is down, allow commit but log warning
    }
  }

  // Auto-commit (NO manual intervention)
  try {
    // Add file to staging
    execSync(`git add "${filePath}"`, {
      stdio: 'pipe'
    });

    // Append security metadata to commit message if available
    const finalMessage = securityMetadata ? `${message}${securityMetadata}` : message;

    // Create commit with security metadata
    execSync(`git commit -m "${finalMessage}"`, {
      stdio: 'pipe'
    });

    console.log(`âœ… Auto-committed: ${path.basename(filePath)}`);
    console.log(`   Author: ${author}`);
    console.log(`   Changes: +${diffResult.linesAdded}/-${diffResult.linesRemoved}`);

    // Update state (O(1) hash map operations)
    const newState: FileState = {
      path: filePath,
      hash: currentHash,
      lastModified: Date.now(),
      author,
      version: '1.0.0' // Will be updated by genetic-versioning.ts
    };

    fileStates.set(filePath, newState);
    hashIndex.set(currentHash, filePath);

    return true;
  } catch (error) {
    console.error(`âŒ Auto-commit failed: ${error}`);
    return false;
  }
}

/**
 * Watch single file for changes
 * O(1) per file
 */
export function watchFile(filePath: string): fs.FSWatcher {
  // Initialize state if first time
  if (!fileStates.has(filePath)) {
    const hash = calculateHash(filePath);
    fileStates.set(filePath, {
      path: filePath,
      hash,
      lastModified: fs.statSync(filePath).mtimeMs,
      author: 'human',
      version: '1.0.0'
    });
    hashIndex.set(hash, filePath);
  }

  // Watch for changes
  return fs.watch(filePath, (eventType) => {
    if (eventType === 'change') {
      // Debounce (wait for write to complete)
      setTimeout(async () => {
        await autoCommit(filePath);
      }, 100);
    }
  });
}

/**
 * Watch directory for .gl and .glass files
 * Recursive, but each file is O(1)
 */
export function watchDirectory(dirPath: string): fs.FSWatcher[] {
  const watchers: fs.FSWatcher[] = [];

  function watchRecursive(dir: string) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        // Skip node_modules and .git
        if (entry.name !== 'node_modules' && entry.name !== '.git') {
          watchRecursive(fullPath);
        }
      } else if (entry.name.endsWith('.gl') || entry.name.endsWith('.glass')) {
        // Watch Grammar Language files
        watchers.push(watchFile(fullPath));
      }
    }
  }

  watchRecursive(dirPath);
  return watchers;
}

/**
 * Get file state by path (O(1))
 */
export function getFileState(filePath: string): FileState | undefined {
  return fileStates.get(filePath);
}

/**
 * Get file path by hash (O(1))
 */
export function getFileByHash(hash: string): string | undefined {
  return hashIndex.get(hash);
}

/**
 * Export all state (for debugging/inspection)
 * Glass box - 100% transparent
 */
export function exportState(): {
  files: FileState[];
  hashes: Record<string, string>;
} {
  return {
    files: Array.from(fileStates.values()),
    hashes: Object.fromEntries(hashIndex)
  };
}
