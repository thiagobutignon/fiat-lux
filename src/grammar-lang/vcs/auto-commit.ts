/**
 * Auto-Commit System - O(1) Version Control
 *
 * Detects changes (human OR AGI) and auto-commits without manual intervention.
 * Uses content-addressable storage for O(1) diff calculation.
 *
 * Philosophy:
 * - Glass box (100% transparent)
 * - O(1) complexity (hash-based)
 * - No manual git commands
 * - Works for human AND AGI changes
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';
import * as crypto from 'crypto';

// ===== TYPES =====

interface FileState {
  path: string;
  hash: string;           // SHA256 content hash
  lastModified: number;   // Timestamp
  author: 'human' | 'agi';
  version: string;        // Semver
}

interface DiffResult {
  linesAdded: number;
  linesRemoved: number;
  diff: string;
}

// ===== STATE (Content-Addressable) =====

// O(1) lookup by file path â†’ state
const fileStates = new Map<string, FileState>();

// O(1) lookup by hash â†’ file path
const hashIndex = new Map<string, string>();

// ===== CORE FUNCTIONS =====

/**
 * Calculate SHA256 hash of file content
 * O(1) per file (constant size .gl/.glass files)
 */
function calculateHash(filePath: string): string {
  const content = fs.readFileSync(filePath, 'utf-8');
  return crypto.createHash('sha256').update(content).digest('hex');
}

/**
 * Detect author based on change patterns
 * AGI: immediate changes (< 1s) from GLM/GSX/GLC
 * Human: typing delay, manual edits
 */
function detectAuthor(filePath: string): 'human' | 'agi' {
  const stats = fs.statSync(filePath);
  const now = Date.now();
  const timeSinceModified = now - stats.mtimeMs;

  // Check if process is AGI tool (GLM/GSX/GLC)
  try {
    const parentProcess = process.env.PARENT_PROCESS || '';
    if (parentProcess.includes('glm') ||
        parentProcess.includes('gsx') ||
        parentProcess.includes('glc')) {
      return 'agi';
    }
  } catch {
    // Fallback to timing heuristic
  }

  // AGI changes are typically immediate (< 1s)
  // Human changes have typing delay (> 1s)
  return timeSinceModified < 1000 ? 'agi' : 'human';
}

/**
 * Calculate diff between current and previous version
 * O(1) - uses git's internal index (content-addressable)
 */
function calculateDiff(filePath: string): DiffResult {
  let diff = '';

  try {
    // Try unstaged diff first
    diff = execSync(`git diff -- "${filePath}"`, {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
  } catch {
    try {
      // Fall back to staged diff
      diff = execSync(`git diff --cached -- "${filePath}"`, {
        encoding: 'utf-8',
        stdio: ['pipe', 'pipe', 'pipe']
      });
    } catch {
      // File not in git yet
      diff = '';
    }
  }

  const linesAdded = (diff.match(/^\+(?!\+)/gm) || []).length;
  const linesRemoved = (diff.match(/^\-(?!\-)/gm) || []).length;

  return { linesAdded, linesRemoved, diff };
}

/**
 * Generate semantic commit message
 * LLM-style message generation
 */
function generateCommitMessage(
  filePath: string,
  author: 'human' | 'agi',
  diffResult: DiffResult
): string {
  const fileName = path.basename(filePath);
  const { linesAdded, linesRemoved } = diffResult;

  // Semantic prefix based on change type
  let prefix = 'feat';
  if (linesAdded === 0 && linesRemoved > 0) {
    prefix = 'refactor';
  } else if (linesAdded > 0 && linesRemoved > 0) {
    prefix = 'fix';
  }

  return `${prefix}: auto-commit ${fileName}

Author: ${author}
Changes: +${linesAdded}/-${linesRemoved}

ðŸ§¬ Auto-generated by VCS (O(1))

Co-Authored-By: ${author === 'agi' ? 'AGI <agi@fiat.ai>' : 'Human <human@fiat.ai>'}`;
}

/**
 * Auto-commit file changes
 * O(1) - no scanning, hash-based detection
 */
export function autoCommit(filePath: string): boolean {
  // Calculate current hash (O(1))
  const currentHash = calculateHash(filePath);
  const previousState = fileStates.get(filePath);

  // Check if file changed (O(1) hash comparison)
  if (previousState && previousState.hash === currentHash) {
    return false; // No changes detected
  }

  // Detect author (O(1))
  const author = detectAuthor(filePath);

  // Calculate diff (O(1) - git uses content-addressable storage)
  const diffResult = calculateDiff(filePath);

  // Skip if no actual changes
  if (diffResult.linesAdded === 0 && diffResult.linesRemoved === 0) {
    return false;
  }

  // Generate commit message
  const message = generateCommitMessage(filePath, author, diffResult);

  // Auto-commit (NO manual intervention)
  try {
    // Add file to staging
    execSync(`git add "${filePath}"`, {
      stdio: 'pipe'
    });

    // Create commit
    execSync(`git commit -m "${message}"`, {
      stdio: 'pipe'
    });

    console.log(`âœ… Auto-committed: ${path.basename(filePath)}`);
    console.log(`   Author: ${author}`);
    console.log(`   Changes: +${diffResult.linesAdded}/-${diffResult.linesRemoved}`);

    // Update state (O(1) hash map operations)
    const newState: FileState = {
      path: filePath,
      hash: currentHash,
      lastModified: Date.now(),
      author,
      version: '1.0.0' // Will be updated by genetic-versioning.ts
    };

    fileStates.set(filePath, newState);
    hashIndex.set(currentHash, filePath);

    return true;
  } catch (error) {
    console.error(`âŒ Auto-commit failed: ${error}`);
    return false;
  }
}

/**
 * Watch single file for changes
 * O(1) per file
 */
export function watchFile(filePath: string): fs.FSWatcher {
  // Initialize state if first time
  if (!fileStates.has(filePath)) {
    const hash = calculateHash(filePath);
    fileStates.set(filePath, {
      path: filePath,
      hash,
      lastModified: fs.statSync(filePath).mtimeMs,
      author: 'human',
      version: '1.0.0'
    });
    hashIndex.set(hash, filePath);
  }

  // Watch for changes
  return fs.watch(filePath, (eventType) => {
    if (eventType === 'change') {
      // Debounce (wait for write to complete)
      setTimeout(() => {
        autoCommit(filePath);
      }, 100);
    }
  });
}

/**
 * Watch directory for .gl and .glass files
 * Recursive, but each file is O(1)
 */
export function watchDirectory(dirPath: string): fs.FSWatcher[] {
  const watchers: fs.FSWatcher[] = [];

  function watchRecursive(dir: string) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        // Skip node_modules and .git
        if (entry.name !== 'node_modules' && entry.name !== '.git') {
          watchRecursive(fullPath);
        }
      } else if (entry.name.endsWith('.gl') || entry.name.endsWith('.glass')) {
        // Watch Grammar Language files
        watchers.push(watchFile(fullPath));
      }
    }
  }

  watchRecursive(dirPath);
  return watchers;
}

/**
 * Get file state by path (O(1))
 */
export function getFileState(filePath: string): FileState | undefined {
  return fileStates.get(filePath);
}

/**
 * Get file path by hash (O(1))
 */
export function getFileByHash(hash: string): string | undefined {
  return hashIndex.get(hash);
}

/**
 * Export all state (for debugging/inspection)
 * Glass box - 100% transparent
 */
export function exportState(): {
  files: FileState[];
  hashes: Record<string, string>;
} {
  return {
    files: Array.from(fileStates.values()),
    hashes: Object.fromEntries(hashIndex)
  };
}
